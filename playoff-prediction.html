<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>CFB Pick'em — Playoff Picture</title>
  <script src="https://cdn.tailwindcss.com"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;600;700&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">

  <link rel="modulepreload" href="./js/supabaseClient.js">
  <link rel="modulepreload" href="./js/nav.js">

  <style>
    :root{
      --cfp-black:#0B0B0B;
      --cfp-charcoal:#111213;
      --cfp-gold:#C99210;
      --cfp-gold-2:#E3B23C;
      --cfp-ivory:#F7F4ED;
      --cfp-gray:#1F2022;
      --ring: 0 0 0 2px var(--cfp-gold) inset, 0 0 0 2px var(--cfp-gold);
    }

    body{
      background:
        radial-gradient(1200px 600px at 50% -10%, rgba(201,146,16,.20), transparent 60%),
        linear-gradient(135deg, rgba(255,255,255,.03) 0 25%, transparent 25% 50%, rgba(255,255,255,.03) 50% 75%, transparent 75% 100%),
        var(--cfp-charcoal);
      background-size:100% 100%,24px 24px,auto;
      color:#e7e7e7;
      font-family:'Roboto',system-ui,-apple-system,Segoe UI,Arial,sans-serif;
      min-height:100vh;
    }

    .table-sticky th{position:sticky;top:0;background-color:var(--cfp-black);z-index:10}
    .gold-shadow{box-shadow:0 0 0 1px rgba(233,185,73,.35),0 0 24px rgba(233,185,73,.08) inset}

    .trophy-oval{width:18px;height:36px;border:2px solid var(--cfp-gold);border-radius:999px;position:relative}
    .trophy-oval::before{content:"";position:absolute;left:50%;top:4px;bottom:4px;width:2px;background:linear-gradient(var(--cfp-gold),var(--cfp-gold-2));transform:translateX(-50%)}

    .cfp-select{background:var(--cfp-black);color:#f1f1f1;border:1px solid rgba(231,231,231,.12)}
    .cfp-select:focus{outline:none;box-shadow:var(--ring)}
    .cfp-card{background:linear-gradient(180deg,var(--cfp-black),var(--cfp-gray));border:1px solid rgba(231,231,231,.10)}

    .badge{font-size:.72rem;line-height:1rem;display:inline-flex;align-items:center;gap:.375rem;padding:.125rem .5rem;border-radius:0}
    .badge-clinch{background:rgba(34,197,94,.18);color:#bbf7d0;border:1px solid rgba(34,197,94,.5)}
    .badge-elim{background:rgba(248,113,113,.16);color:#fecaca;border:1px solid rgba(248,113,113,.5)}
    .badge-hunt{background:#2b2c2e;color:#d1d5db;border:1px solid rgba(209,213,219,.12)}

    .table th,.table td{border-color:rgba(231,231,231,.08)}
    .table tbody tr:hover{background:rgba(233,185,73,.06)}

    .stripe{background:repeating-linear-gradient(90deg,transparent 0 40px,rgba(233,185,73,.12) 40px 48px)}

    .playoff-divider td{
      padding:.15rem 0;background:transparent;border-top:2px solid var(--cfp-gold);color:var(--cfp-ivory);
      text-align:center;letter-spacing:.08em;font-size:.75rem;text-transform:uppercase;
    }

    th.sticky-col-1, td.sticky-col-1{
      position: sticky; left: 0; z-index: 25; background: var(--cfp-black);
      box-shadow: 1px 0 0 rgba(231,231,231,.08) inset;
    }
    thead th.sticky-col-1{ z-index: 50; }

    @media (max-width: 640px){
      th, td { padding-top: .4rem !important; padding-bottom: .4rem !important; }
      thead th { font-size: .8rem; }
      .badge { font-size: .65rem; padding: .1rem .4rem; }
      .table tbody td { font-size: .85rem; }
    }

    nav[data-nav="root"]{position:relative;z-index:60;pointer-events:auto}

    /* Highlight logged-in user's team row */
    tr[data-me="true"]{
      background-color: rgba(255,255,255,0.05);
    }
    tr[data-me="true"] .sticky-col-1{
      font-weight:700;
      text-shadow:0 0 8px rgba(0,0,0,.6);
      box-shadow:1px 0 0 rgba(233,185,73,.4) inset;
    }
    tr[data-me="true"]:hover{
      background:
        linear-gradient(90deg, rgba(233,185,73,.24), transparent 65%);
    }
  </style>
</head>

<body data-page="playoff">
  <div class="max-w-7xl mx-auto p-4 md:p-6">
    <div id="site-nav"></div>

    <!-- Header -->
    <header class="cfp-card rounded-none stripe gold-shadow mb-5">
      <div class="flex items-center justify-between px-4 py-4 md:px-6 md:py-5">
        <div class="flex items-center gap-3 md:gap-4">
          <span class="trophy-oval" aria-hidden="true"></span>
          <div>
            <p class="text-[11px] tracking-[.25em] text-gray-300 uppercase">College Football Pick'em</p>
            <h1 class="font-['Oswald',_sans-serif] text-3xl md:text-4xl font-bold text-[var(--cfp-ivory)] leading-tight">
              Playoff Picture
            </h1>
          </div>
        </div>
        <div class="flex flex-col md:flex-row items-start md:items-center gap-2 md:gap-3 text-sm">
          <label class="hidden md:block text-gray-300">Season</label>
          <select id="season-select" class="cfp-select rounded-none px-3 py-2 text-sm min-w-[110px]"></select>
        </div>
      </div>
      <div class="border-t border-[rgba(231,231,231,.08)] px-4 md:px-6 py-2 text-xs text-gray-300">
        <span id="status">Loading…</span>
      </div>
    </header>

    <!-- Legend -->
    <div class="mb-3 text-xs text-gray-300 flex flex-wrap items-center gap-3">
      <span class="badge badge-clinch">Clinched playoff</span>
      <span class="badge badge-elim">Eliminated</span>
      <span class="badge badge-hunt">In the hunt</span>
      <span class="ml-2">
        Max Season Pts = 66 − (# decided picked games) + (current correct picks). Win % = correct picks / decided picked games. Ties don’t count as clinched.
      </span>
    </div>

    <!-- Main table -->
    <div class="cfp-card rounded-none gold-shadow overflow-auto">
      <table class="table min-w-full text-sm">
        <thead class="table-sticky">
          <tr class="border-b border-[rgba(231,231,231,.12)]">
            <th class="sticky-col-1 text-left pl-4 pr-2 py-3 font-semibold text-[var(--cfp-ivory)] bg-[var(--cfp-black)] font-[Oswald] tracking-wide">
              Live Seed
            </th>
            <th class="text-left px-3 py-3 font-semibold text-[var(--cfp-ivory)] bg-[var(--cfp-black)] font-[Oswald] tracking-wide">
              Team
            </th>
            <th class="text-center px-3 py-3 font-semibold text-[var(--cfp-ivory)] bg-[var(--cfp-black)] font-[Oswald] tracking-wide">
              Points (Win %)
            </th>
            <th class="text-center px-3 py-3 font-semibold text-[var(--cfp-ivory)] bg-[var(--cfp-black)] font-[Oswald] tracking-wide">
              Max Season Pts
            </th>
            <th class="text-center px-3 py-3 font-semibold text-[var(--cfp-ivory)] bg-[var(--cfp-black)] font-[Oswald] tracking-wide">
              Status
            </th>
            <th class="text-center px-3 py-3 font-semibold text-[var(--cfp-ivory)] bg-[var(--cfp-black)] font-[Oswald] tracking-wide">
              Best After This Week
            </th>
            <th class="text-center px-3 py-3 font-semibold text-[var(--cfp-ivory)] bg-[var(--cfp-black)] font-[Oswald] tracking-wide">
              Max Possible Seed (Season)
            </th>
          </tr>
        </thead>
        <tbody id="playoff-body"></tbody>
      </table>
    </div>
  </div>

  <!-- Page script -->
  <script type="module">
    import initNav from './js/nav.js';
    import { supabase } from './js/supabaseClient.js';

    // ---- DOM ----
    const seasonSelect = document.getElementById('season-select');
    const statusEl     = document.getElementById('status');
    const tbody        = document.getElementById('playoff-body');

    // ---- Constants ----
    const TOTAL_GAMES_SEASON = 66;

    // ---- State ----
    let seasons = [];
    let currentSeason = null;
    let currentWeek = null; // latest week that has at least one picked game

    let teams = [];
    let winsByTeam = {};             // points from decided games
    let maxSeasonPointsByTeam = {};  // best-case total for full season
    let bestRankAfterWeek = {};      // best rank after currentWeek
    let seasonBestSeedByTeam = {};   // best possible seed at end of season
    let winPctByTeam = {};           // win % for each team

    let totalDecidedGames = 0;       // # of picked games with a winner
    let currentTeamId = null;        // logged-in user's team highlight

    const STORAGE_KEYS = {
      lastSeason: 'cfb_last_season_v1'
    };

    // ---------- Utility ----------
    function status(msg,isErr=false){
      statusEl.className = 'text-sm ' + (isErr ? 'text-red-300' : 'text-gray-300');
      statusEl.textContent = msg;
    }

    function stripAccents(s){
      try { return s.normalize('NFD').replace(/\p{Diacritic}/gu, ''); }
      catch { return s; }
    }
    function norm(v){
      if(!v) return '';
      return stripAccents(String(v))
        .toLowerCase()
        .replace(/&/g,' and ')
        .replace(/\./g,'')
        .replace(/[^a-z0-9\s]/g,' ')
        .replace(/\s+/g,' ')
        .trim();
    }
    const stToState = s => s.replace(/\bst\b/g,'state');
    const stateToSt = s => s.replace(/\bstate\b/g,'st');
    function sameTeam(a,b){
      const na = norm(a), nb = norm(b);
      return na === nb || stToState(na) === stToState(nb) || stateToSt(na) === stateToSt(nb);
    }

    function getCachedNumber(key){
      const v = localStorage.getItem(key);
      const n = v!=null ? Number(v) : NaN;
      return Number.isFinite(n) ? n : null;
    }
    function setCachedNumber(key,val){
      if(Number.isFinite(val)) localStorage.setItem(key,String(val));
    }

    function ordinal(n){
      const s = ["th","st","nd","rd"], v = n%100;
      return n + (s[(v-20)%10] || s[v] || s[0]);
    }

    function parseStartCT(value){
      if (!value) return null;
      try{
        const d = new Date(value);
        const ts = d.getTime();
        return Number.isFinite(ts) ? ts : null;
      }catch{
        return null;
      }
    }

    // ---------- Current logged-in team ----------
    async function loadCurrentUserTeam(){
      try{
        const { data: { session } } = await supabase.auth.getSession();
        if (!session) return;

        const { data: myTeams, error: tErr } = await supabase
          .from('teams')
          .select('team_id, team_name')
          .eq('user_id', session.user.id)
          .order('team_name', { ascending: true });

        if (tErr) {
          console.warn('loadCurrentUserTeam error:', tErr.message);
          return;
        }
        if (myTeams && myTeams.length){
          currentTeamId = myTeams[0].team_id;
        }
      }catch(e){
        console.warn('loadCurrentUserTeam exception:', e);
      }
    }

    // ---------- Startup ----------
    async function startup(){
      await initNav();
      await loadCurrentUserTeam();
      await loadSeasons();

      const hintedSeason = getCachedNumber(STORAGE_KEYS.lastSeason);
      if (Number.isFinite(hintedSeason) && seasons.includes(hintedSeason)) {
        currentSeason = hintedSeason;
      } else {
        currentSeason = seasons[seasons.length-1];
      }
      seasonSelect.value = String(currentSeason);

      await refreshAll();

      seasonSelect.onchange = async () => {
        currentSeason = Number(seasonSelect.value);
        setCachedNumber(STORAGE_KEYS.lastSeason, currentSeason);
        await refreshAll();
      };
    }
    startup();

    // ---------- Load seasons ----------
    async function loadSeasons(){
      status('Loading seasons…');
      const { data, error } = await supabase
        .from('all_games')
        .select('cfb_season')
        .not('cfb_season', 'is', null);

      if(error){ status(error.message,true); throw error; }

      seasons = [...new Set((data||[]).map(r => Number(r.cfb_season)).filter(Number.isFinite))].sort((a,b)=>a-b);
      if(!seasons.length){ status('No seasons found.',true); throw new Error('no seasons'); }

      seasonSelect.innerHTML = seasons.map(s => `<option value="${s}">${s}</option>`).join('');
    }

    // ---------- Determine latest active week for season ----------
    async function loadCurrentWeekForSeason(season){
      const { data, error } = await supabase
        .from('all_games')
        .select('week')
        .eq('cfb_season', season)
        .eq('picked', true)
        .not('week', 'is', null);

      if(error){
        status(error.message, true);
        currentWeek = null;
        return;
      }

      const wks = (data || []).map(r => r.week).filter(w => w != null);
      if (!wks.length){
        currentWeek = null;
      } else {
        currentWeek = Math.max(...wks);
      }
    }

    // ---------- Refresh everything for a season ----------
    async function refreshAll(){
      status(`Computing playoff picture for ${currentSeason}…`);

      await loadCurrentWeekForSeason(currentSeason);
      await loadTeams();
      await computeSeasonPointsAndMax();
      await computeBestRanksForCurrentWeek();
      renderTable();

      if (currentWeek != null){
        status(`Season ${currentSeason} • Using picks through week ${currentWeek}`);
      } else {
        status(`Season ${currentSeason} • No picked games yet`);
      }
    }

    async function loadTeams(){
      const { data, error } = await supabase
        .from('teams')
        .select('team_id, team_name')
        .order('team_name',{ascending:true});

      if(error){ status(error.message,true); throw error; }

      teams = data || [];
    }

    // ---------- Season points + Max season points (66 games total) ----------
    async function computeSeasonPointsAndMax(){
      winsByTeam = {};
      maxSeasonPointsByTeam = {};
      winPctByTeam = {};
      totalDecidedGames = 0;

      // All picked games for this season that already have a winner
      const { data: decidedGames, error: gErr } = await supabase
        .from('all_games')
        .select('GameId, winner')
        .eq('cfb_season', currentSeason)
        .eq('picked', true)
        .not('winner', 'is', null);

      if (gErr){
        status(gErr.message, true);
        return;
      }

      const decidedRows = decidedGames || [];
      const decidedIds = [...new Set(decidedRows.map(g => g.GameId))];
      totalDecidedGames = decidedIds.length;

      const winnerByGame = {};
      decidedRows.forEach(g => {
        winnerByGame[g.GameId] = g.winner;
      });

      // Compute current wins from decided games
      if (decidedIds.length){
        const { data: picksDecided, error: pErr } = await supabase
          .from('picks')
          .select('team_id, game_id, pick')
          .in('game_id', decidedIds);

        if (pErr){
          status(pErr.message, true);
          return;
        }

        (picksDecided || []).forEach(p => {
          const winner = winnerByGame[p.game_id];
          if (!winner) return;
          if (sameTeam(p.pick, winner)){
            winsByTeam[p.team_id] = (winsByTeam[p.team_id] || 0) + 1;
          }
        });
      }

      const remainingGames = Math.max(0, TOTAL_GAMES_SEASON - totalDecidedGames);

      // Ensure every team has entries and compute max season points + win %
      teams.forEach(t => {
        const id = t.team_id;
        const wins = winsByTeam[id] || 0;
        winsByTeam[id] = wins;
        maxSeasonPointsByTeam[id] = wins + remainingGames;

        if (totalDecidedGames > 0){
          winPctByTeam[id] = wins / totalDecidedGames;
        } else {
          winPctByTeam[id] = null;
        }
      });
    }

    // ---------- Best possible rank after CURRENT week ----------
    async function computeBestRanksForCurrentWeek(){
      bestRankAfterWeek = {};

      if (currentWeek == null){
        // No picked games at all yet
        teams.forEach(t => { bestRankAfterWeek[t.team_id] = null; });
        return;
      }

      // Games for this week (only picked games)
      const { data: games, error: gErr } = await supabase
        .from('all_games')
        .select('GameId, winner, Status, "Start (CT)"')
        .eq('cfb_season', currentSeason)
        .eq('picked', true)
        .eq('week', currentWeek);

      if(gErr){ status(gErr.message,true); return; }

      const weekGames = games || [];
      if (!weekGames.length){
        teams.forEach(t => { bestRankAfterWeek[t.team_id] = null; });
        return;
      }

      // Do NOT compute anything until first game of the week has kicked
      let earliestStart = null;
      weekGames.forEach(g => {
        const ts = parseStartCT(g["Start (CT)"]);
        if (ts != null){
          if (earliestStart == null || ts < earliestStart){
            earliestStart = ts;
          }
        }
      });

      const now = Date.now();
      // If we have a valid earliest start and it's still in the future, no Best After This Week yet
      if (earliestStart != null && now < earliestStart){
        teams.forEach(t => { bestRankAfterWeek[t.team_id] = null; });
        return;
      }

      // Once games have kicked, compute based only on REMAINING undecided games this week
      const undecidedIds = weekGames
        .filter(g => !g.winner)
        .map(g => g.GameId);

      const teamIds = teams.map(t => t.team_id);

      if (!undecidedIds.length){
        // No undecided games this week; best rank is just current live seed
        const sorted = [...teams].sort((a,b)=>{
          const pa = winsByTeam[a.team_id] || 0;
          const pb = winsByTeam[b.team_id] || 0;
          if (pb !== pa) return pb - pa;
          return a.team_name.localeCompare(b.team_name);
        });
        const rankById = {};
        sorted.forEach((t,idx)=>{ rankById[t.team_id] = idx+1; });
        bestRankAfterWeek = rankById;
        return;
      }

      // Picks for undecided games this week
      const { data: pickRows, error: pErr } = await supabase
        .from('picks')
        .select('team_id, game_id, pick')
        .in('game_id', undecidedIds);

      if(pErr){ status(pErr.message,true); return; }

      const remPicksByTeam = {};
      (pickRows || []).forEach(p => {
        if (!remPicksByTeam[p.team_id]) remPicksByTeam[p.team_id] = {};
        remPicksByTeam[p.team_id][p.game_id] = p.pick;
      });

      teamIds.forEach(id => {
        const ptsI = winsByTeam[id] || 0;
        let cantBeatCount = 0;

        teamIds.forEach(otherId => {
          if (otherId === id) return;
          const ptsJ = winsByTeam[otherId] || 0;

          let delta = 0;
          for (const gId of undecidedIds){
            const pi = remPicksByTeam[id]?.[gId] || null;
            const pj = remPicksByTeam[otherId]?.[gId] || null;

            if (!pi && !pj) continue;

            if (pi && pj){
              if (sameTeam(pi, pj)){
                // same pick, move together
                continue;
              } else {
                // choose outcome where I am right and they are wrong
                delta += 1;
              }
            } else if (pi && !pj){
              // I picked, they didn’t; assume it goes my way
              delta += 1;
            } else if (!pi && pj){
              // they picked, I didn’t; best case for me is they’re wrong (no change)
              continue;
            }
          }

          const bestDiff = (ptsI - ptsJ) + delta;
          // ties are NOT enough to be "ahead" → consistent with your example
          if (bestDiff <= 0){
            cantBeatCount++;
          }
        });

        bestRankAfterWeek[id] = cantBeatCount + 1;
      });
    }

    // ---------- Clinched / Eliminated / Best season seed ----------
    function computePlayoffFlagsAndBestSeeds(){
      const minPts = {};
      const maxPts = {};

      teams.forEach(t => {
        const id = t.team_id;
        const cur = winsByTeam[id] || 0;
        const mx  = maxSeasonPointsByTeam[id] || cur;
        minPts[id] = cur;
        maxPts[id] = mx;
      });

      const flags = {};
      const bestSeed = {};

      teams.forEach(t => {
        const id = t.team_id;
        const myMin = minPts[id];
        const myMax = maxPts[id];

        // How many teams are GUARANTEED to finish ahead of my best possible?
        let surelyAhead = 0;
        teams.forEach(o => {
          if (o.team_id === id) return;
          if (minPts[o.team_id] > myMax) surelyAhead++;
        });
        const eliminated = surelyAhead >= 4;

        // Clinched: even in worst case I'm strictly ahead of the 4th-best other's best case
        const othersMax = teams
          .filter(o => o.team_id !== id)
          .map(o => maxPts[o.team_id])
          .sort((a,b)=>b-a);
        const fourthBest = othersMax[3] ?? -Infinity;
        const clinched = myMin > fourthBest; // strictly greater — ties not enough

        flags[id] = { clinched, eliminated };
        bestSeed[id] = surelyAhead + 1; // minimum possible seed (1 = best)
      });

      return { flags, bestSeed };
    }

    // ---------- Render ----------
    function renderTable(){
      tbody.innerHTML = '';

      const { flags, bestSeed } = computePlayoffFlagsAndBestSeeds();
      seasonBestSeedByTeam = bestSeed;

      // Sort by current points, then name
      const sorted = [...teams].sort((a,b)=>{
        const pa = winsByTeam[a.team_id] || 0;
        const pb = winsByTeam[b.team_id] || 0;
        if (pb !== pa) return pb - pa;
        return a.team_name.localeCompare(b.team_name);
      });

      const seedById = {};
      sorted.forEach((t,idx) => { seedById[t.team_id] = idx+1; });

      sorted.forEach(t => {
        const id = t.team_id;
        const pts = winsByTeam[id] || 0;
        const maxSeason = maxSeasonPointsByTeam[id] || pts;
        const { clinched, eliminated } = flags[id] || { clinched:false, eliminated:false };
        const bestWeekRank = bestRankAfterWeek[id];
        const bestSeasonSeed = seasonBestSeedByTeam[id];

        const tr = document.createElement('tr');
        tr.className = 'border-t border-[rgba(231,231,231,.08)] hover:bg-[rgba(233,185,73,.04)]';

        if (currentTeamId != null && id === currentTeamId){
          tr.dataset.me = 'true';
        }

        // Live seed
        const tdSeed = document.createElement('td');
        tdSeed.className = 'sticky-col-1 pl-4 pr-2 py-2 font-semibold text-[var(--cfp-ivory)]';
        const liveSeed = seedById[id];
        tdSeed.textContent = liveSeed <= 4 ? `#${liveSeed}` : String(liveSeed);
        tr.appendChild(tdSeed);

        // Team
        const tdTeam = document.createElement('td');
        tdTeam.className = 'px-3 py-2';
        tdTeam.textContent = t.team_name;
        tr.appendChild(tdTeam);

        // Points (Win %)
        const tdPts = document.createElement('td');
        tdPts.className = 'px-3 py-2 text-center font-semibold';
        const pct = winPctByTeam[id];
        let pctText = '—';
        if (pct != null){
          pctText = (pct * 100).toFixed(1) + '%';
        }
        tdPts.textContent = `${pts} (${pctText})`;
        tr.appendChild(tdPts);

        // Max Season Pts
        const tdMax = document.createElement('td');
        tdMax.className = 'px-3 py-2 text-center';
        tdMax.textContent = maxSeason.toString();
        tr.appendChild(tdMax);

        // Status
        const tdStatus = document.createElement('td');
        tdStatus.className = 'px-3 py-2 text-center';
        if (clinched){
          tdStatus.innerHTML = '<span class="badge badge-clinch">Clinched</span>';
        } else if (eliminated){
          tdStatus.innerHTML = '<span class="badge badge-elim">Eliminated</span>';
        } else {
          tdStatus.innerHTML = '<span class="badge badge-hunt">In the hunt</span>';
        }
        tr.appendChild(tdStatus);

        // Best After This Week
        const tdBestWeek = document.createElement('td');
        tdBestWeek.className = 'px-3 py-2 text-center text-sm';
        if (bestWeekRank == null){
          tdBestWeek.textContent = '—';
        } else {
          tdBestWeek.textContent = ordinal(bestWeekRank);
        }
        tr.appendChild(tdBestWeek);

        // Max Possible Seed (Season)
        const tdBestSeason = document.createElement('td');
        tdBestSeason.className = 'px-3 py-2 text-center text-sm';
        if (bestSeasonSeed == null){
          tdBestSeason.textContent = '—';
        } else {
          tdBestSeason.textContent = ordinal(bestSeasonSeed);
        }
        tr.appendChild(tdBestSeason);

        tbody.appendChild(tr);
      });

      // Cut line after #4
      if (sorted.length > 4){
        const divider = document.createElement('tr');
        divider.className = 'playoff-divider';
        const td = document.createElement('td');
        td.colSpan = 7;
        td.textContent = 'Projected Playoff Cut Line';
        divider.appendChild(td);

        const children = Array.from(tbody.children);
        if (children.length >= 4){
          tbody.insertBefore(divider, children[4].nextSibling);
        } else {
          tbody.appendChild(divider);
        }
      }
    }
  </script>
</body>
</html>